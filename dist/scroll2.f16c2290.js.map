{"version":3,"sources":["node_modules/rolly.js/dist/rolly.umd.js","js/scroll2.js"],"names":["r","view","document","body","native","init"],"mappings":";;ACAA,ADAA;AACA;AACA;AACA;ACDA,ADEA,ICFMA,CAAC,GAAG,oBAAM;AACdC,ADEF,ECFEA,IAAI,EAAEC,QAAQ,CAACC,IADD;AAEdC,ADEF,ECFEA,MAAM,EAAE,KAFM,CAGd;ADEF;ACLgB,ADMhB,CCNU,CAAV;AAKAJ,ADEA,CCFC,CAACK,IAAF;ADGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"scroll2.f16c2290.js","sourceRoot":"..","sourcesContent":["/*!\n    * rolly.js v0.4.0\n    * (c) 2020 Mickael Chanrion\n    * Released under the MIT license\n    */\n  \n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = global || self, global.rolly = factory());\n}(this, function () { 'use strict';\n\n\t/*\n\tobject-assign\n\t(c) Sindre Sorhus\n\t@license MIT\n\t*/\n\t/* eslint-disable no-unused-vars */\n\tvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\n\tvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\tvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\n\tfunction toObject(val) {\n\t\tif (val === null || val === undefined) {\n\t\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t\t}\n\n\t\treturn Object(val);\n\t}\n\n\tfunction shouldUseNative() {\n\t\ttry {\n\t\t\tif (!Object.assign) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\t\ttest1[5] = 'de';\n\t\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test2 = {};\n\t\t\tfor (var i = 0; i < 10; i++) {\n\t\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t\t}\n\t\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\t\treturn test2[n];\n\t\t\t});\n\t\t\tif (order2.join('') !== '0123456789') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\t\tvar test3 = {};\n\t\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\t\ttest3[letter] = letter;\n\t\t\t});\n\t\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tvar objectAssign = shouldUseNative() ? Object.assign : function (target, source) {\n\t\tvar from;\n\t\tvar to = toObject(target);\n\t\tvar symbols;\n\n\t\tfor (var s = 1; s < arguments.length; s++) {\n\t\t\tfrom = Object(arguments[s]);\n\n\t\t\tfor (var key in from) {\n\t\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\t\tto[key] = from[key];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (getOwnPropertySymbols) {\n\t\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn to;\n\t};\n\n\tfunction E () {\n\t  // Keep this empty so it's easier to inherit from\n\t  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)\n\t}\n\n\tE.prototype = {\n\t  on: function (name, callback, ctx) {\n\t    var e = this.e || (this.e = {});\n\n\t    (e[name] || (e[name] = [])).push({\n\t      fn: callback,\n\t      ctx: ctx\n\t    });\n\n\t    return this;\n\t  },\n\n\t  once: function (name, callback, ctx) {\n\t    var self = this;\n\t    function listener () {\n\t      self.off(name, listener);\n\t      callback.apply(ctx, arguments);\n\t    }\n\t    listener._ = callback;\n\t    return this.on(name, listener, ctx);\n\t  },\n\n\t  emit: function (name) {\n\t    var data = [].slice.call(arguments, 1);\n\t    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();\n\t    var i = 0;\n\t    var len = evtArr.length;\n\n\t    for (i; i < len; i++) {\n\t      evtArr[i].fn.apply(evtArr[i].ctx, data);\n\t    }\n\n\t    return this;\n\t  },\n\n\t  off: function (name, callback) {\n\t    var e = this.e || (this.e = {});\n\t    var evts = e[name];\n\t    var liveEvents = [];\n\n\t    if (evts && callback) {\n\t      for (var i = 0, len = evts.length; i < len; i++) {\n\t        if (evts[i].fn !== callback && evts[i].fn._ !== callback)\n\t          liveEvents.push(evts[i]);\n\t      }\n\t    }\n\n\t    // Remove event from queue to prevent memory leak\n\t    // Suggested by https://github.com/lazd\n\t    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910\n\n\t    (liveEvents.length)\n\t      ? e[name] = liveEvents\n\t      : delete e[name];\n\n\t    return this;\n\t  }\n\t};\n\n\tvar tinyEmitter = E;\n\n\tvar commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\n\tfunction createCommonjsModule(fn, module) {\n\t\treturn module = { exports: {} }, fn(module, module.exports), module.exports;\n\t}\n\n\tvar lethargy = createCommonjsModule(function (module, exports) {\n\t// Generated by CoffeeScript 1.9.2\n\t(function() {\n\t  var root;\n\n\t  root = exports !== null ? exports : this;\n\n\t  root.Lethargy = (function() {\n\t    function Lethargy(stability, sensitivity, tolerance, delay) {\n\t      this.stability = stability != null ? Math.abs(stability) : 8;\n\t      this.sensitivity = sensitivity != null ? 1 + Math.abs(sensitivity) : 100;\n\t      this.tolerance = tolerance != null ? 1 + Math.abs(tolerance) : 1.1;\n\t      this.delay = delay != null ? delay : 150;\n\t      this.lastUpDeltas = (function() {\n\t        var i, ref, results;\n\t        results = [];\n\t        for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {\n\t          results.push(null);\n\t        }\n\t        return results;\n\t      }).call(this);\n\t      this.lastDownDeltas = (function() {\n\t        var i, ref, results;\n\t        results = [];\n\t        for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {\n\t          results.push(null);\n\t        }\n\t        return results;\n\t      }).call(this);\n\t      this.deltasTimestamp = (function() {\n\t        var i, ref, results;\n\t        results = [];\n\t        for (i = 1, ref = this.stability * 2; 1 <= ref ? i <= ref : i >= ref; 1 <= ref ? i++ : i--) {\n\t          results.push(null);\n\t        }\n\t        return results;\n\t      }).call(this);\n\t    }\n\n\t    Lethargy.prototype.check = function(e) {\n\t      var lastDelta;\n\t      e = e.originalEvent || e;\n\t      if (e.wheelDelta != null) {\n\t        lastDelta = e.wheelDelta;\n\t      } else if (e.deltaY != null) {\n\t        lastDelta = e.deltaY * -40;\n\t      } else if ((e.detail != null) || e.detail === 0) {\n\t        lastDelta = e.detail * -40;\n\t      }\n\t      this.deltasTimestamp.push(Date.now());\n\t      this.deltasTimestamp.shift();\n\t      if (lastDelta > 0) {\n\t        this.lastUpDeltas.push(lastDelta);\n\t        this.lastUpDeltas.shift();\n\t        return this.isInertia(1);\n\t      } else {\n\t        this.lastDownDeltas.push(lastDelta);\n\t        this.lastDownDeltas.shift();\n\t        return this.isInertia(-1);\n\t      }\n\t      return false;\n\t    };\n\n\t    Lethargy.prototype.isInertia = function(direction) {\n\t      var lastDeltas, lastDeltasNew, lastDeltasOld, newAverage, newSum, oldAverage, oldSum;\n\t      lastDeltas = direction === -1 ? this.lastDownDeltas : this.lastUpDeltas;\n\t      if (lastDeltas[0] === null) {\n\t        return direction;\n\t      }\n\t      if (this.deltasTimestamp[(this.stability * 2) - 2] + this.delay > Date.now() && lastDeltas[0] === lastDeltas[(this.stability * 2) - 1]) {\n\t        return false;\n\t      }\n\t      lastDeltasOld = lastDeltas.slice(0, this.stability);\n\t      lastDeltasNew = lastDeltas.slice(this.stability, this.stability * 2);\n\t      oldSum = lastDeltasOld.reduce(function(t, s) {\n\t        return t + s;\n\t      });\n\t      newSum = lastDeltasNew.reduce(function(t, s) {\n\t        return t + s;\n\t      });\n\t      oldAverage = oldSum / lastDeltasOld.length;\n\t      newAverage = newSum / lastDeltasNew.length;\n\t      if (Math.abs(oldAverage) < Math.abs(newAverage * this.tolerance) && (this.sensitivity < Math.abs(newAverage))) {\n\t        return direction;\n\t      } else {\n\t        return false;\n\t      }\n\t    };\n\n\t    Lethargy.prototype.showLastUpDeltas = function() {\n\t      return this.lastUpDeltas;\n\t    };\n\n\t    Lethargy.prototype.showLastDownDeltas = function() {\n\t      return this.lastDownDeltas;\n\t    };\n\n\t    return Lethargy;\n\n\t  })();\n\n\t}).call(commonjsGlobal);\n\t});\n\n\tvar support = (function getSupport() {\n\t    return {\n\t        hasWheelEvent: 'onwheel' in document,\n\t        hasMouseWheelEvent: 'onmousewheel' in document,\n\t        hasTouch: 'ontouchstart' in document,\n\t        hasTouchWin: navigator.msMaxTouchPoints && navigator.msMaxTouchPoints > 1,\n\t        hasPointer: !!window.navigator.msPointerEnabled,\n\t        hasKeyDown: 'onkeydown' in document,\n\t        isFirefox: navigator.userAgent.indexOf('Firefox') > -1\n\t    };\n\t})();\n\n\tvar toString = Object.prototype.toString,\n\t    hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\tvar bindallStandalone = function(object) {\n\t    if(!object) return console.warn('bindAll requires at least one argument.');\n\n\t    var functions = Array.prototype.slice.call(arguments, 1);\n\n\t    if (functions.length === 0) {\n\n\t        for (var method in object) {\n\t            if(hasOwnProperty$1.call(object, method)) {\n\t                if(typeof object[method] == 'function' && toString.call(object[method]) == \"[object Function]\") {\n\t                    functions.push(method);\n\t                }\n\t            }\n\t        }\n\t    }\n\n\t    for(var i = 0; i < functions.length; i++) {\n\t        var f = functions[i];\n\t        object[f] = bind(object[f], object);\n\t    }\n\t};\n\n\t/*\n\t    Faster bind without specific-case checking. (see https://coderwall.com/p/oi3j3w).\n\t    bindAll is only needed for events binding so no need to make slow fixes for constructor\n\t    or partial application.\n\t*/\n\tfunction bind(func, context) {\n\t  return function() {\n\t    return func.apply(context, arguments);\n\t  };\n\t}\n\n\tvar Lethargy = lethargy.Lethargy;\n\n\n\n\tvar EVT_ID = 'virtualscroll';\n\n\tvar src = VirtualScroll;\n\n\tvar keyCodes = {\n\t    LEFT: 37,\n\t    UP: 38,\n\t    RIGHT: 39,\n\t    DOWN: 40,\n\t    SPACE: 32\n\t};\n\n\tfunction VirtualScroll(options) {\n\t    bindallStandalone(this, '_onWheel', '_onMouseWheel', '_onTouchStart', '_onTouchMove', '_onKeyDown');\n\n\t    this.el = window;\n\t    if (options && options.el) {\n\t        this.el = options.el;\n\t        delete options.el;\n\t    }\n\t    this.options = objectAssign({\n\t        mouseMultiplier: 1,\n\t        touchMultiplier: 2,\n\t        firefoxMultiplier: 15,\n\t        keyStep: 120,\n\t        preventTouch: false,\n\t        unpreventTouchClass: 'vs-touchmove-allowed',\n\t        limitInertia: false,\n\t        useKeyboard: true,\n\t        useTouch: true\n\t    }, options);\n\n\t    if (this.options.limitInertia) this._lethargy = new Lethargy();\n\n\t    this._emitter = new tinyEmitter();\n\t    this._event = {\n\t        y: 0,\n\t        x: 0,\n\t        deltaX: 0,\n\t        deltaY: 0\n\t    };\n\t    this.touchStartX = null;\n\t    this.touchStartY = null;\n\t    this.bodyTouchAction = null;\n\n\t    if (this.options.passive !== undefined) {\n\t        this.listenerOptions = {passive: this.options.passive};\n\t    }\n\t}\n\n\tVirtualScroll.prototype._notify = function(e) {\n\t    var evt = this._event;\n\t    evt.x += evt.deltaX;\n\t    evt.y += evt.deltaY;\n\n\t   this._emitter.emit(EVT_ID, {\n\t        x: evt.x,\n\t        y: evt.y,\n\t        deltaX: evt.deltaX,\n\t        deltaY: evt.deltaY,\n\t        originalEvent: e\n\t   });\n\t};\n\n\tVirtualScroll.prototype._onWheel = function(e) {\n\t    var options = this.options;\n\t    if (this._lethargy && this._lethargy.check(e) === false) return;\n\t    var evt = this._event;\n\n\t    // In Chrome and in Firefox (at least the new one)\n\t    evt.deltaX = e.wheelDeltaX || e.deltaX * -1;\n\t    evt.deltaY = e.wheelDeltaY || e.deltaY * -1;\n\n\t    // for our purpose deltamode = 1 means user is on a wheel mouse, not touch pad\n\t    // real meaning: https://developer.mozilla.org/en-US/docs/Web/API/WheelEvent#Delta_modes\n\t    if(support.isFirefox && e.deltaMode == 1) {\n\t        evt.deltaX *= options.firefoxMultiplier;\n\t        evt.deltaY *= options.firefoxMultiplier;\n\t    }\n\n\t    evt.deltaX *= options.mouseMultiplier;\n\t    evt.deltaY *= options.mouseMultiplier;\n\n\t    this._notify(e);\n\t};\n\n\tVirtualScroll.prototype._onMouseWheel = function(e) {\n\t    if (this.options.limitInertia && this._lethargy.check(e) === false) return;\n\n\t    var evt = this._event;\n\n\t    // In Safari, IE and in Chrome if 'wheel' isn't defined\n\t    evt.deltaX = (e.wheelDeltaX) ? e.wheelDeltaX : 0;\n\t    evt.deltaY = (e.wheelDeltaY) ? e.wheelDeltaY : e.wheelDelta;\n\n\t    this._notify(e);\n\t};\n\n\tVirtualScroll.prototype._onTouchStart = function(e) {\n\t    var t = (e.targetTouches) ? e.targetTouches[0] : e;\n\t    this.touchStartX = t.pageX;\n\t    this.touchStartY = t.pageY;\n\t};\n\n\tVirtualScroll.prototype._onTouchMove = function(e) {\n\t    var options = this.options;\n\t    if(options.preventTouch\n\t        && !e.target.classList.contains(options.unpreventTouchClass)) {\n\t        e.preventDefault();\n\t    }\n\n\t    var evt = this._event;\n\n\t    var t = (e.targetTouches) ? e.targetTouches[0] : e;\n\n\t    evt.deltaX = (t.pageX - this.touchStartX) * options.touchMultiplier;\n\t    evt.deltaY = (t.pageY - this.touchStartY) * options.touchMultiplier;\n\n\t    this.touchStartX = t.pageX;\n\t    this.touchStartY = t.pageY;\n\n\t    this._notify(e);\n\t};\n\n\tVirtualScroll.prototype._onKeyDown = function(e) {\n\t    var evt = this._event;\n\t    evt.deltaX = evt.deltaY = 0;\n\t    var windowHeight = window.innerHeight - 40;\n\n\t    switch(e.keyCode) {\n\t        case keyCodes.LEFT:\n\t        case keyCodes.UP:\n\t            evt.deltaY = this.options.keyStep;\n\t            break;\n\n\t        case keyCodes.RIGHT:\n\t        case keyCodes.DOWN:\n\t            evt.deltaY = - this.options.keyStep;\n\t            break;\n\t        case e.shiftKey:\n\t            evt.deltaY = windowHeight;\n\t            break;\n\t        case keyCodes.SPACE:\n\t            evt.deltaY = - windowHeight;\n\t            break;\n\t        default:\n\t            return;\n\t    }\n\n\t    this._notify(e);\n\t};\n\n\tVirtualScroll.prototype._bind = function() {\n\t    if(support.hasWheelEvent) this.el.addEventListener('wheel', this._onWheel, this.listenerOptions);\n\t    if(support.hasMouseWheelEvent) this.el.addEventListener('mousewheel', this._onMouseWheel, this.listenerOptions);\n\n\t    if(support.hasTouch && this.options.useTouch) {\n\t        this.el.addEventListener('touchstart', this._onTouchStart, this.listenerOptions);\n\t        this.el.addEventListener('touchmove', this._onTouchMove, this.listenerOptions);\n\t    }\n\n\t    if(support.hasPointer && support.hasTouchWin) {\n\t        this.bodyTouchAction = document.body.style.msTouchAction;\n\t        document.body.style.msTouchAction = 'none';\n\t        this.el.addEventListener('MSPointerDown', this._onTouchStart, true);\n\t        this.el.addEventListener('MSPointerMove', this._onTouchMove, true);\n\t    }\n\n\t    if(support.hasKeyDown && this.options.useKeyboard) document.addEventListener('keydown', this._onKeyDown);\n\t};\n\n\tVirtualScroll.prototype._unbind = function() {\n\t    if(support.hasWheelEvent) this.el.removeEventListener('wheel', this._onWheel);\n\t    if(support.hasMouseWheelEvent) this.el.removeEventListener('mousewheel', this._onMouseWheel);\n\n\t    if(support.hasTouch) {\n\t        this.el.removeEventListener('touchstart', this._onTouchStart);\n\t        this.el.removeEventListener('touchmove', this._onTouchMove);\n\t    }\n\n\t    if(support.hasPointer && support.hasTouchWin) {\n\t        document.body.style.msTouchAction = this.bodyTouchAction;\n\t        this.el.removeEventListener('MSPointerDown', this._onTouchStart, true);\n\t        this.el.removeEventListener('MSPointerMove', this._onTouchMove, true);\n\t    }\n\n\t    if(support.hasKeyDown && this.options.useKeyboard) document.removeEventListener('keydown', this._onKeyDown);\n\t};\n\n\tVirtualScroll.prototype.on = function(cb, ctx) {\n\t  this._emitter.on(EVT_ID, cb, ctx);\n\n\t  var events = this._emitter.e;\n\t  if (events && events[EVT_ID] && events[EVT_ID].length === 1) this._bind();\n\t};\n\n\tVirtualScroll.prototype.off = function(cb, ctx) {\n\t  this._emitter.off(EVT_ID, cb, ctx);\n\n\t  var events = this._emitter.e;\n\t  if (!events[EVT_ID] || events[EVT_ID].length <= 0) this._unbind();\n\t};\n\n\tVirtualScroll.prototype.reset = function() {\n\t    var evt = this._event;\n\t    evt.x = 0;\n\t    evt.y = 0;\n\t};\n\n\tVirtualScroll.prototype.destroy = function() {\n\t    this._emitter.off();\n\t    this._unbind();\n\t};\n\n\t// check document first so it doesn't error in node.js\n\tvar style = typeof document != 'undefined'\n\t  ? document.createElement('p').style\n\t  : {};\n\n\tvar prefixes = ['O', 'ms', 'Moz', 'Webkit'];\n\tvar upper = /([A-Z])/g;\n\tvar memo = {};\n\n\t/**\n\t * prefix `key`\n\t *\n\t *   prefix('transform') // => WebkitTransform\n\t *\n\t * @param {String} key\n\t * @return {String}\n\t * @api public\n\t */\n\tfunction prefix(key){\n\t  // Camel case\n\t  key = key.replace(/-([a-z])/g, function(_, char){\n\t    return char.toUpperCase()\n\t  });\n\n\t  // Without prefix\n\t  if (style[key] !== undefined) return key\n\n\t  // With prefix\n\t  var Key = key.charAt(0).toUpperCase() + key.slice(1);\n\t  var i = prefixes.length;\n\t  while (i--) {\n\t    var name = prefixes[i] + Key;\n\t    if (style[name] !== undefined) return name\n\t  }\n\n\t  return key\n\t}\n\n\t/**\n\t * Memoized version of `prefix`\n\t *\n\t * @param {String} key\n\t * @return {String}\n\t * @api public\n\t */\n\tfunction prefixMemozied(key){\n\t  return key in memo\n\t    ? memo[key]\n\t    : memo[key] = prefix(key)\n\t}\n\n\t/**\n\t * Create a dashed prefix\n\t *\n\t * @param {String} key\n\t * @return {String}\n\t * @api public\n\t */\n\tfunction prefixDashed(key){\n\t  key = prefix(key);\n\t  if (upper.test(key)) {\n\t    key = '-' + key.replace(upper, '-$1');\n\t    upper.lastIndex = 0;\n\t  }\n\t  return key.toLowerCase()\n\t}\n\n\tvar prefix_1 = prefixMemozied;\n\tvar dash = prefixDashed;\n\tprefix_1.dash = dash;\n\n\tvar utils = {\n\t  getCSSTransform: function getCSSTransform(value, vertical) {\n\t    return vertical\n\t      ? (\"translate3d(0, \" + value + \"px, 0)\")\n\t      : (\"translate3d(\" + value + \"px, 0, 0)\");\n\t  },\n\n\t  getElements: function getElements(selector, context) {\n\t    if ( context === void 0 ) context = document;\n\n\t    return Array.from(context.querySelectorAll(selector));\n\t  },\n\t};\n\n\tfunction objectWithoutProperties (obj, exclude) { var target = {}; for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k) && exclude.indexOf(k) === -1) target[k] = obj[k]; return target; }\n\n\tvar Scene = function Scene(context, options) {\n\t  this.options = options;\n\n\t  this.state = {\n\t    caching: false,\n\t    cache: null,\n\t    inView: false,\n\t    active: false,\n\t    progress: 0,\n\t    progressInView: 0,\n\t  };\n\n\t  this.DOM = { context: context };\n\t};\n\n\t/**\n\t * A promise to get cache for the scene.\n\t * The default cache object is as follow:\n\t * - context: the DOM element of the scene.\n\t * - type: the type of the scene.\n\t * - top: distance between the top of the view and the top of the scene at the initial state.\n\t * - bottom: distance between the top of the view and the bottom of the scene at the initial\n\t * state.\n\t * - left: distance between the left of the view and the left of the scene at the initial state.\n\t * - right: distance between the left of the view and the right of the scene at the initial state.\n\t * - size: height of the scene (or width on horizontal mode).\n\t * - speed: the speed of the scene.\n\t * - trigger: the trigger position (e.g.: 'middle', 'bottom', '100px', '10%').\n\t *\n\t * The cache of the scene is extendable by providing a method in options: `options.scenes.${sceneType}.cache`.\n\t * This method gives an object that contains:\n\t * - cache: the computed cache so far.\n\t * - state: the state of the scene.\n\t * - globalState: the state of the rolly instance\n\t * Simply return new properties in an object to extend the cache.\n\t *\n\t * @param {object} globalState - The state of the rolly instance.\n\t */\n\tScene.prototype.cache = function cache (globalState) {\n\t    var this$1 = this;\n\n\t  return new Promise(function (resolve, reject) {\n\t    this$1.state.caching = true;\n\n\t    var ref = this$1.options;\n\t      var vertical = ref.vertical;\n\t    // TODO: see when we need this\n\t    // const scrollOffset = globalState.target;\n\t    var scrollOffset = 0;\n\n\t    var viewSize = vertical ? globalState.height : globalState.width;\n\n\t    var ref$1 = this$1.DOM;\n\t      var context = ref$1.context;\n\t    context.style.display = null;\n\t    var computedStyle = window.getComputedStyle(context);\n\t    if (computedStyle.display === 'none') {\n\t      this$1.state.cache = null;\n\t      resolve(this$1.state.cache);\n\t    }\n\n\t    if (computedStyle.display === 'inline') {\n\t      context.style.display = 'block';\n\t    }\n\n\t    context.style[globalState.transformPrefix] = null;\n\n\t    var bounding = context.getBoundingClientRect();\n\n\t    var type = context.getAttribute('data-scene');\n\n\t    var options = this$1.options.scenes;\n\t    var sceneOptions = options[type] || {};\n\n\t    var cache = {\n\t      context: context,\n\t      type: type,\n\t      top: vertical ? bounding.top + scrollOffset : bounding.top,\n\t      bottom: vertical ? bounding.bottom + scrollOffset : bounding.bottom,\n\t      left: vertical ? bounding.left : bounding.left + scrollOffset,\n\t      right: vertical ? bounding.right : bounding.right + scrollOffset,\n\t      size: vertical ? bounding.height : bounding.width,\n\t      speed:\n\t        parseFloat(context.getAttribute('data-speed'))\n\t        || sceneOptions.speed\n\t        || options.speed,\n\t      trigger:\n\t        context.getAttribute('data-trigger')\n\t        || sceneOptions.trigger\n\t        || options.trigger,\n\t    };\n\n\t    var trigger = cache.trigger;\n\n\t    var triggerOffset = 0;\n\t    if (trigger === 'middle') { triggerOffset = viewSize / 2; }\n\t    else if (trigger === 'end') { triggerOffset = viewSize; }\n\t    // px from top\n\t    else if (trigger.slice(-2) === 'px') { triggerOffset = parseFloat(trigger); }\n\t    // percentage\n\t    else if (trigger.slice(-1) === '%') {\n\t      triggerOffset = (viewSize * parseFloat(trigger)) / 100;\n\t    }\n\n\t    cache.triggerOffset = triggerOffset;\n\n\t    var start = vertical\n\t      ? cache.top + cache.size / 2 - globalState.height / 2\n\t      : cache.left + cache.size / 2 - globalState.width / 2;\n\t    cache.offset = start - start * cache.speed;\n\n\t    // Cache for custom scenes\n\t    var getCache = sceneOptions.cache || options.cache;\n\t    if (getCache) {\n\t      if (getCache) {\n\t        var extendedCache = getCache.call(this$1, {\n\t          cache: cache,\n\t          globalState: globalState,\n\t          sceneState: this$1.state,\n\t        });\n\n\t        cache = Object.assign({}, cache, extendedCache);\n\t      }\n\t    }\n\n\t    this$1.state.cache = cache;\n\t    this$1.state.caching = false;\n\t    resolve(this$1.state.cache);\n\t  });\n\t};\n\n\t/**\n\t * Animation frame callback (called at every frames).\n\t * @param {object} globalState - The state of the rolly instance.\n\t */\n\tScene.prototype.change = function change (globalState) {\n\t  if (!this.state.cache || this.state.caching) { return false; }\n\n\t  var viewSize = this.options.vertical\n\t    ? globalState.height\n\t    : globalState.width;\n\t  var ref = this.state;\n\t    var cache = ref.cache;\n\t    var active = ref.active;\n\n\t  var ref$1 = this.calc(globalState);\n\t    var inView = ref$1.inView;\n\t    var transform = ref$1.transform;\n\t    var start = ref$1.start;\n\t  this.state.progress = this.getProgress(transform);\n\t  this.state.progressInView = this.getProgressInView(start, viewSize);\n\n\t  var ref$2 = this.options.scenes;\n\t    var sceneOptions = ref$2[cache.type];\n\t    var rest = objectWithoutProperties( ref$2, [cache.type] );\n\t    var options = rest; // eslint-disable-line prefer-const\n\n\t  if (!sceneOptions) {\n\t    sceneOptions = {};\n\t  }\n\n\t  // The data we send to every custom functions\n\t  var data = { globalState: globalState, sceneState: this.state, transform: transform };\n\n\t  // Check if inView value changed\n\t  if (this.state.inView !== inView) {\n\t    // Trigger appear/disappear callbacks\n\t    var action = inView ? 'appear' : 'disappear';\n\t    if (sceneOptions[action]) { sceneOptions[action].call(this, data); }\n\t    else if (options[action]) { options[action].call(this, data); }\n\n\t    this.state.inView = inView;\n\t  }\n\n\t  // Check and then trigger callbacks\n\t  if (inView) {\n\t    this.DOM.context.style.willChange = 'transform';\n\n\t    // Run\n\t    if (sceneOptions.change) { sceneOptions.change.call(this, data); }\n\t    else if (options.change) { options.change.call(this, data); }\n\n\t    // Enter\n\t    if (this.checkEnter(active, this.state.progress)) {\n\t      this.state.active = true;\n\t      if (sceneOptions.enter) {\n\t        sceneOptions.enter.call(this, data);\n\t      } else if (options.enter) {\n\t        options.enter.call(this, data);\n\t      }\n\t    } else if (this.checkLeave(active, this.state.progress)) {\n\t      // Leave\n\t      this.state.active = false;\n\t      if (sceneOptions.leave) {\n\t        sceneOptions.leave.call(this, data);\n\t      } else if (options.leave) {\n\t        options.leave.call(this, data);\n\t      }\n\t    }\n\n\t    // Transform\n\t    if (sceneOptions.transform) { sceneOptions.transform.call(this, data); }\n\t    else if (options.transform) { options.transform.call(this, data); }\n\t    else {\n\t      this.DOM.context.style[\n\t        globalState.transformPrefix\n\t      ] = utils.getCSSTransform(transform, this.options.vertical);\n\t    }\n\t  } else {\n\t    this.DOM.context.style[\n\t      globalState.transformPrefix\n\t    ] = utils.getCSSTransform(Math.max(globalState.bounding, viewSize + 50), this.options.vertical);\n\t    this.DOM.context.style.willChange = null;\n\t  }\n\n\t  return true;\n\t};\n\n\t/**\n\t * Computes useful values for the scene.\n\t * @param {object} globalState - The state of the rolly instance\n\t * @return {object} Values as follow:\n\t * - transform: the transform value according to the speed\n\t * - start: distance between the start position of the view and the start position of the scene context (top|left)\n\t * - end: distance between the end position of the view and the end position of the scene context (bottom|right)\n\t * - inView: whether the scene is in the viewport\n\t */\n\tScene.prototype.calc = function calc (globalState) {\n\t  var ref = this.options;\n\t    var vertical = ref.vertical;\n\t  var ref$1 = this.state.cache;\n\t    var top = ref$1.top;\n\t    var right = ref$1.right;\n\t    var bottom = ref$1.bottom;\n\t    var left = ref$1.left;\n\t    var speed = ref$1.speed;\n\t    var offset = ref$1.offset;\n\t  var width = globalState.width;\n\t    var height = globalState.height;\n\t    var current = globalState.current;\n\n\t  var transform = current * -speed - offset;\n\n\t  var start = Math.round((vertical ? top : left) + transform);\n\t  var end = Math.round((vertical ? bottom : right) + transform);\n\t  var inView = end > 0 && start < (vertical ? height : width);\n\n\t  return {\n\t    transform: transform, start: start, end: end, inView: inView,\n\t  };\n\t};\n\n\t/**\n\t * Gets the progress of the scene in relation to its trigger (default trigger position is 'middle').\n\t * @param {number} transform - The transform position of the scene.\n\t * @return {number} The progress position.\n\t */\n\tScene.prototype.getProgress = function getProgress (transform) {\n\t  var ref = this.options;\n\t    var vertical = ref.vertical;\n\t  var ref$1 = this.state;\n\t    var cache = ref$1.cache;\n\t  var triggerOffset = cache.triggerOffset;\n\n\t  var position = -transform + triggerOffset;\n\n\t  var progress = (position - (vertical ? cache.top : cache.left)) / cache.size;\n\n\t  if (progress < 0 || progress > 1) { return -1; }\n\t  return progress;\n\t};\n\n\t/**\n\t * Gets the progress of the scene in relation to the viewport.\n\t * @param {number} start - The distance between the start position of the view and the start.\n\t * @param {*} viewSize - The size of the view.\n\t */\n\tScene.prototype.getProgressInView = function getProgressInView (start, viewSize) {\n\t  return (viewSize - start) / (viewSize + this.state.cache.size);\n\t};\n\n\t/**\n\t * Checks if the trigger met the scene.\n\t * @param {boolean} active - Whether the scene is active.\n\t * @param {number} progress - The progress position of the scene related to the trigger\n\t * @return {boolean} The result.\n\t */\n\tScene.prototype.checkEnter = function checkEnter (active, progress) {\n\t  return !active && progress >= 0 && progress <= 1;\n\t};\n\n\t/**\n\t * Checks if the trigger left the scene.\n\t * @param {boolean} active - Whether the scene is active.\n\t * @param {number} progress - The progress position of the scene related to the trigger\n\t * @return {boolean} The result.\n\t */\n\tScene.prototype.checkLeave = function checkLeave (active, progress) {\n\t  return active && progress === -1;\n\t};\n\n\tvar ScrollBar = function ScrollBar(parent, globalState, setTarget, options) {\n\t  this.options = options;\n\n\t  this.DOM = this.render(parent);\n\n\t  this.state = {\n\t    clicked: false,\n\t    thumb: { size: 0 },\n\t  };\n\n\t  this.cache(globalState);\n\n\t  this.setTarget = setTarget;\n\t};\n\n\tvar prototypeAccessors = { thumbSize: { configurable: true } };\n\n\t/**\n\t * Sets cache for scroll bar.\n\t * @param {object} globalState - The state of the rolly instance.\n\t */\n\tScrollBar.prototype.cache = function cache (globalState) {\n\t  this.state.cache = {\n\t    bounding: globalState.bounding,\n\t    viewSize: this.options.vertical ? globalState.height : globalState.width,\n\t  };\n\t  this.updateThumbSize();\n\t};\n\n\t/**\n\t * Animation frame callback (called at every frames).\n\t * @param {object} globalState - The state of the rolly instance.\n\t */\n\tScrollBar.prototype.change = function change (ref) {\n\t    var current = ref.current;\n\t    var transformPrefix = ref.transformPrefix;\n\n\t  var ref$1 = this.state.cache;\n\t    var bounding = ref$1.bounding;\n\t    var viewSize = ref$1.viewSize;\n\t  var ref$2 = this;\n\t    var thumbSize = ref$2.thumbSize;\n\t  var value = Math.abs(current) / (bounding / (viewSize - thumbSize))\n\t    + thumbSize / 0.5\n\t    - thumbSize;\n\n\t  var clamp = Math.max(0, Math.min(value - thumbSize, value + thumbSize));\n\t  this.DOM.thumb.style[transformPrefix] = utils.getCSSTransform(\n\t    clamp.toFixed(2),\n\t    this.options.vertical\n\t  );\n\t};\n\n\t/**\n\t * Computes the target value from the scroll bar (based on event client viewport position).\n\t * @param {number} client - The client position.\n\t * @return {number} The target.\n\t */\n\tScrollBar.prototype.calc = function calc (client) {\n\t  return client * (this.state.cache.bounding / this.state.cache.viewSize);\n\t};\n\n\t/**\n\t * Renders the scroll bar.\n\t * @param {object} parent - The parent DOM of the scroll bar.\n\t * @return {object} - The list of DOM elements (parent, context, thumb).\n\t */\n\tScrollBar.prototype.render = function render (parent) {\n\t  var context = document.createElement('div');\n\t  var direction = this.options.vertical ? 'y' : 'x';\n\t  context.className = \"rolly-scroll-bar \" + direction + \"-scroll\";\n\n\t  var thumb = document.createElement('div');\n\t  thumb.className = 'rolly-scroll-bar-thumb';\n\n\t  context.appendChild(thumb);\n\t  parent.appendChild(context);\n\n\t  return { parent: parent, context: context, thumb: thumb };\n\t};\n\n\t/**\n\t * Starts listening events (mouse interactions).\n\t */\n\tScrollBar.prototype.on = function on () {\n\t  this.boundFns = {\n\t    click: this.click.bind(this),\n\t    mouseDown: this.mouseDown.bind(this),\n\t    mouseMove: this.mouseMove.bind(this),\n\t    mouseUp: this.mouseUp.bind(this),\n\t  };\n\n\t  this.DOM.context.addEventListener('click', this.boundFns.click);\n\t  this.DOM.context.addEventListener('mousedown', this.boundFns.mouseDown);\n\n\t  document.addEventListener('mousemove', this.boundFns.mouseMove);\n\t  document.addEventListener('mouseup', this.boundFns.mouseUp);\n\t};\n\n\t/**\n\t * Stops listening events (mouse interactions).\n\t */\n\tScrollBar.prototype.off = function off () {\n\t  if (!this.boundFns) { return false; }\n\t  this.DOM.context.removeEventListener('click', this.boundFns.click);\n\t  this.DOM.context.removeEventListener('mousedown', this.boundFns.mouseDown);\n\n\t  document.removeEventListener('mousemove', this.boundFns.mouseMove);\n\t  document.removeEventListener('mouseup', this.boundFns.mouseUp);\n\t  delete this.boundFns;\n\t  return true;\n\t};\n\n\t/**\n\t * Click event callback.\n\t * @param {object} event - The event data.\n\t */\n\tScrollBar.prototype.click = function click (event) {\n\t  var value = this.calc(this.options.vertical ? event.clientY : event.clientX);\n\t  this.setTarget(value);\n\t};\n\n\t/**\n\t * Mouse down event callback.\n\t * @param {object} event - The event data.\n\t */\n\tScrollBar.prototype.mouseDown = function mouseDown (event) {\n\t  event.preventDefault();\n\t  if (event.which === 1) {\n\t    this.state.clicked = true;\n\t  }\n\t  this.DOM.parent.classList.add('is-dragging-scroll-bar');\n\t};\n\n\t/**\n\t * Mouse move event callback.\n\t * @param {object} event - The event data.\n\t */\n\tScrollBar.prototype.mouseMove = function mouseMove (event) {\n\t  if (this.state.clicked) {\n\t    var value = this.calc(this.options.vertical ? event.clientY : event.clientX);\n\t    this.setTarget(value);\n\t  }\n\t};\n\n\t/**\n\t * Mouse up event callback.\n\t * @param {object} event - The event data.\n\t */\n\tScrollBar.prototype.mouseUp = function mouseUp (event) {\n\t  this.state.clicked = false;\n\t  this.DOM.parent.classList.remove('is-dragging-scroll-bar');\n\t};\n\n\t/**\n\t * Gets the size of the thumb (heigh or width on horizontal mode).\n\t * @return {number} - The size of the thumb.\n\t */\n\tprototypeAccessors.thumbSize.get = function () {\n\t  return this.state.thumb.size;\n\t};\n\n\t/**\n\t * Sets the size of the thumb (heigh or width on horizontal mode).\n\t * @param {number} - The size of the thumb.\n\t */\n\tprototypeAccessors.thumbSize.set = function (size) {\n\t  this.state.thumb.size = size;\n\t  var prop = this.options.vertical ? 'height' : 'width';\n\t  this.DOM.thumb.style[prop] = size + \"px\";\n\t};\n\n\t/**\n\t * Updates the size of the thumb.\n\t * This method is called when the content changes or on a resize for instance.\n\t */\n\tScrollBar.prototype.updateThumbSize = function updateThumbSize () {\n\t  var ref = this.state.cache;\n\t    var bounding = ref.bounding;\n\t  if (bounding <= 0) {\n\t    this.DOM.context.classList.add('is-hidden');\n\t    this.thumbSize = 0;\n\t    return;\n\t  }\n\n\t  this.DOM.context.classList.remove('is-hidden');\n\t  var ref$1 = this.state.cache;\n\t    var viewSize = ref$1.viewSize;\n\t  this.thumbSize = viewSize * (viewSize / (bounding + viewSize));\n\t};\n\n\t/**\n\t * Destroy the scroll bar.\n\t * - removes from the DOM.\n\t * - calls {@link ScrollBar#off}.\n\t */\n\tScrollBar.prototype.destroy = function destroy () {\n\t  this.off();\n\t  this.DOM.parent.removeChild(this.DOM.context);\n\t};\n\n\tObject.defineProperties( ScrollBar.prototype, prototypeAccessors );\n\n\t/*\n\t ** Private methods\n\t */\n\tvar privated = {\n\t  /**\n\t   * Gets all functions that needs to be bound with the rolly's scope\n\t   */\n\t  getBoundFns: function getBoundFns() {\n\t    var this$1 = this;\n\n\t    var fns = {};\n\t    ['resize', 'debounceScroll', 'virtualScroll'].map(\n\t      function (fn) { return (fns[fn] = privated[fn].bind(this$1)); } // eslint-disable-line no-return-assign\n\t    );\n\t    return fns;\n\t  },\n\n\t  /**\n\t   * Initializes the state of the rolly instance.\n\t   */\n\t  initState: function initState() {\n\t    this.state = {\n\t      current: 0,\n\t      previous: 0,\n\t      target: null,\n\t      width: window.innerWidth,\n\t      height: window.innerHeight,\n\t      bounding: 0,\n\t      ready: false,\n\t      preLoaded: false,\n\t      changing: false,\n\t      // The transform property to use\n\t      transformPrefix: prefix_1('transform'),\n\t    };\n\n\t    this.privateState = {\n\t      // Animation frame\n\t      rAF: undefined,\n\t      /*\n\t       * It seems that under heavy load, Firefox will still call the RAF\n\t       * callback even though the RAF has been canceled. To prevent\n\t       * that we set a flag to prevent any callback to be executed when\n\t       * RAF is removed.\n\t       */\n\t      isRAFCanceled: false,\n\n\t      // Native scroll\n\t      debounceScroll: { timer: null, tick: false },\n\n\t      scrollTo: {},\n\t    };\n\t  },\n\n\t  /**\n\t   * Initializes scenes\n\t   */\n\t  initScenes: function initScenes() {\n\t    var this$1 = this;\n\n\t    this.scenes = [];\n\n\t    utils\n\t      .getElements(this.options.scenes.selector, this.DOM.view)\n\t      .forEach(function (scene) { return this$1.scenes.push(new Scene(scene, this$1.options)); });\n\t  },\n\n\t  /*\n\t   ** Animation frame methods\n\t   */\n\n\t  /**\n\t   * Animation frame callback (called at every frames).\n\t   * Automatically stops when |target - current| < 0.1.\n\t   */\n\t  change: function change() {\n\t    var this$1 = this;\n\n\t    if (this.privateState.isRAFCanceled) { return; }\n\t    privated.rAF.call(this);\n\n\t    var diff = this.state.target - this.state.current;\n\t    var delta = diff * this.options.ease;\n\n\t    // If diff between target and current states is < 0.1, stop running animation\n\t    if (Math.abs(diff) < 0.1) {\n\t      privated.cAF.call(this);\n\t      delta = 0;\n\t      this.state.current = this.state.target;\n\t      if (this.state.changing) {\n\t        this.state.changing = false;\n\t        this.options.changeEnd(this.state);\n\t      }\n\t    } else {\n\t      this.state.current += delta;\n\t      if (!this.state.changing) {\n\t        this.state.changing = true;\n\t        this.options.changeStart(this.state);\n\t      }\n\t    }\n\n\t    if (Math.abs(diff) < 10 && this.privateState.scrollTo.callback) {\n\t      this.privateState.scrollTo.callback(this.state);\n\t      this.privateState.scrollTo.callback = null;\n\t    }\n\n\t    // Set scroll bar thumb position\n\t    if (this.scrollBar) {\n\t      this.scrollBar.change(this.state);\n\t    }\n\n\t    // Call custom change\n\t    this.options.change(this.state);\n\n\t    this.scenes.forEach(function (scene) { return scene.change(this$1.state); });\n\n\t    this.state.previous = this.state.current;\n\t  },\n\n\t  /**\n\t   * Request an animation frame.\n\t   */\n\t  rAF: function rAF() {\n\t    this.privateState.isRAFCanceled = false;\n\t    this.privateState.rAF = requestAnimationFrame(privated.change.bind(this));\n\t  },\n\n\t  /**\n\t   * Cancel a requested animation frame.\n\t   */\n\t  cAF: function cAF() {\n\t    this.privateState.isRAFCanceled = true;\n\t    this.privateState.rAF = cancelAnimationFrame(this.privateState.rAF);\n\t  },\n\n\t  /*\n\t   ** Events\n\t   */\n\n\t  /**\n\t   * Checks if rolly is ready.\n\t   */\n\t  ready: function ready() {\n\t    if (\n\t      this.state.ready\n\t      && (this.options.preload ? this.state.preLoaded : true)\n\t    ) {\n\t      this.options.ready(this.state);\n\t      return true;\n\t    }\n\t    return false;\n\t  },\n\n\t  /**\n\t   * Virtual scroll event callback.\n\t   * @param {object} e - The event data.\n\t   */\n\t  virtualScroll: function virtualScroll(e) {\n\t    if (this.privateState.scrollTo.callback) { return; }\n\t    var delta = this.options.vertical ? e.deltaY : e.deltaX;\n\t    privated.setTarget.call(this, this.state.target + delta * -1);\n\t  },\n\n\t  /**\n\t   * Native scroll event callback.\n\t   * @param {object} e - The event data.\n\t   */\n\t  debounceScroll: function debounceScroll(e) {\n\t    var this$1 = this;\n\n\t    if (this.privateState.scrollTo.callback) { return; }\n\t    var isWindow = this.DOM.listener === document.body;\n\n\t    var target;\n\n\t    if (this.options.vertical) {\n\t      target = isWindow\n\t        ? window.scrollY || window.pageYOffset\n\t        : this.DOM.listener.scrollTop;\n\t    } else {\n\t      target = isWindow\n\t        ? window.scrollX || window.pageXOffset\n\t        : this.DOM.listener.scrollLeft;\n\t    }\n\n\t    privated.setTarget.call(this, target);\n\n\t    clearTimeout(this.privateState.debounceScroll.timer);\n\n\t    if (!this.privateState.debounceScroll.tick) {\n\t      this.privateState.debounceScroll.tick = true;\n\t      this.DOM.listener.classList.add('is-scrolling');\n\t    }\n\n\t    this.privateState.debounceScroll.timer = setTimeout(function () {\n\t      this$1.privateState.debounceScroll.tick = false;\n\t      this$1.DOM.listener.classList.remove('is-scrolling');\n\t    }, 200);\n\t  },\n\n\t  /**\n\t   * Resize event callback.\n\t   * @param {object} e - The event data.\n\t   */\n\t  resize: function resize(e) {\n\t    var this$1 = this;\n\n\t    var prop = this.options.vertical ? 'height' : 'width';\n\t    this.state.height = window.innerHeight;\n\t    this.state.width = window.innerWidth;\n\n\t    // Calc bounding\n\t    var ref = this.options;\n\t    var native = ref.native;\n\t    var vertical = ref.vertical;\n\t    var bounding = this.DOM.view.getBoundingClientRect();\n\t    this.state.bounding = vertical\n\t      ? bounding.height - (native ? 0 : this.state.height)\n\t      : bounding.right - (native ? 0 : this.state.width);\n\n\t    // Set scroll bar thumb height (according to view height)\n\t    if (this.scrollBar) {\n\t      this.scrollBar.cache(this.state);\n\t    } else if (native) {\n\t      this.DOM.scroll.style[prop] = (this.state.bounding) + \"px\";\n\t    }\n\n\t    privated.setTarget.call(this, this.state.target);\n\n\t    // Get cache for scenes\n\t    this.scenes.forEach(function (scene) { return scene.cache(this$1.state); });\n\t  },\n\n\t  /*\n\t   ** Utils\n\t   */\n\n\t  /**\n\t   * Extends options.\n\t   * @param {object} options - The options to extend.\n\t   * @return {object} The extended options.\n\t   */\n\t  extendOptions: function extendOptions(options) {\n\t    var opts = this.options ? this.options : privated.getDefaults.call(this);\n\t    options.virtualScroll = Object.assign({}, opts.virtualScroll, options.virtualScroll);\n\t    options.scenes = Object.assign({}, opts.scenes, options.scenes);\n\n\t    return Object.assign({}, opts, options);\n\t  },\n\n\t  /**\n\t   * Preload images in the view of the rolly instance.\n\t   * Useful if the view contains images that might not have fully loaded when the instance is created (because when an\n\t   * image is loaded, the total height changes).\n\t   * @param {function} callback - The function to run when images are loaded.\n\t   */\n\t  preloadImages: function preloadImages(callback) {\n\t    var images = utils.getElements('img', this.DOM.listener);\n\n\t    if (!images.length) {\n\t      if (callback) { callback(); }\n\t      return;\n\t    }\n\n\t    images.forEach(function (image) {\n\t      var img = document.createElement('img');\n\t      img.onload = function () {\n\t        images.splice(images.indexOf(image), 1);\n\t        if (images.length === 0) { callback(); }\n\t      };\n\n\t      img.src = image.currentSrc || image.src;\n\t    });\n\t  },\n\n\t  /**\n\t   * Adds a fake scroll height.\n\t   */\n\t  addFakeScrollHeight: function addFakeScrollHeight() {\n\t    var scroll = document.createElement('div');\n\t    scroll.className = 'rolly-scroll-view';\n\t    this.DOM.scroll = scroll;\n\t    this.DOM.listener.appendChild(this.DOM.scroll);\n\t  },\n\n\t  /**\n\t   * Removes a fake scroll height.\n\t   */\n\t  removeFakeScrollHeight: function removeFakeScrollHeight() {\n\t    this.DOM.listener.removeChild(this.DOM.scroll);\n\t  },\n\n\t  /**\n\t   * Adds a fake scroll bar.\n\t   */\n\t  addFakeScrollBar: function addFakeScrollBar() {\n\t    this.scrollBar = new ScrollBar(\n\t      this.DOM.listener,\n\t      this.state,\n\t      privated.setTarget.bind(this),\n\t      this.options\n\t    );\n\t  },\n\n\t  /**\n\t   * Removes the fake scroll bar.\n\t   */\n\t  removeFakeScrollBar: function removeFakeScrollBar() {\n\t    this.scrollBar.destroy();\n\t  },\n\n\t  /*\n\t   ** Getters and setters\n\t   */\n\n\t  /**\n\t   * Gets the default options for the rolly instance.\n\t   * @return {object} The default options.\n\t   */\n\t  getDefaults: function getDefaults() {\n\t    return {\n\t      vertical: true,\n\t      listener: document.body,\n\t      view: utils.getElements('.rolly-view')[0] || null,\n\t      native: true,\n\t      preload: true,\n\t      autoUpdate: true,\n\t      ready: function () { },\n\t      change: function () { },\n\t      changeStart: function () { },\n\t      changeEnd: function () { },\n\t      ease: 0.075,\n\t      virtualScroll: {\n\t        limitInertia: false,\n\t        mouseMultiplier: 0.5,\n\t        touchMultiplier: 1.5,\n\t        firefoxMultiplier: 30,\n\t        preventTouch: true,\n\t      },\n\t      noScrollBar: false,\n\t      scenes: {\n\t        selector: '[data-scene]',\n\t        speed: 1,\n\t        trigger: 'middle',\n\t      },\n\t    };\n\t  },\n\n\t  /**\n\t   * Gets the node element on which will be attached the scroll event listener (in case of native behavior).\n\t   * @return {object} The node element.\n\t   */\n\t  getNodeListener: function getNodeListener() {\n\t    return this.DOM.listener === document.body ? window : this.DOM.listener;\n\t  },\n\n\t  /**\n\t   * Sets the target position with auto clamping.\n\t   */\n\t  setTarget: function setTarget(target) {\n\t    // if (target === null) return;\n\t    this.state.target = Math.round(\n\t      Math.max(0, Math.min(target, this.state.bounding))\n\t    );\n\t    !this.privateState.rAF && privated.rAF.call(this);\n\t  },\n\t};\n\n\tvar Rolly = function Rolly(options) {\n\t  if ( options === void 0 ) options = {};\n\n\t  this.boundFns = privated.getBoundFns.call(this);\n\n\t  // Extend default options\n\t  this.options = privated.extendOptions.call(this, options);\n\n\t  this.DOM = {\n\t    listener: this.options.listener,\n\t    view: this.options.view,\n\t  };\n\n\t  privated.initScenes.call(this);\n\t};\n\n\t/**\n\t * Initializes the rolly instance.\n\t * - adds DOM classes.\n\t * - if native, adds fake height.\n\t * - else if `options.noScrollBar` is false, adds a fake scroll bar.\n\t * - calls {@link Rolly#on}.\n\t */\n\tRolly.prototype.init = function init () {\n\t    var this$1 = this;\n\n\t  // Instantiate virtual scroll native option is false\n\t  this.virtualScroll = this.options.native\n\t    ? null\n\t    : new src(this.options.virtualScroll);\n\n\t  privated.initState.call(this);\n\n\t  var type = this.options.native ? 'native' : 'virtual';\n\t  var direction = this.options.vertical ? 'y' : 'x';\n\n\t  this.DOM.listener.classList.add((\"is-\" + type + \"-scroll\"));\n\t  this.DOM.listener.classList.add((direction + \"-scroll\"));\n\t  this.DOM.view.classList.add('rolly-view');\n\n\t  this.options.native\n\t    ? privated.addFakeScrollHeight.call(this)\n\t    : !this.options.noScrollBar && privated.addFakeScrollBar.call(this);\n\n\t  if (this.options.preload) {\n\t    privated.preloadImages.call(this, function () {\n\t      this$1.state.preLoaded = true;\n\t      this$1.boundFns.resize();\n\t      privated.ready.call(this$1);\n\t    });\n\t  }\n\n\t  this.on();\n\t};\n\n\t/**\n\t * Enables the rolly instance.\n\t * - starts listening events (scroll and resize),\n\t * - requests an animation frame if {@param rAF} is true.\n\t * @param {boolean} rAF - whether to request an animation frame.\n\t */\n\tRolly.prototype.on = function on (rAF) {\n\t    if ( rAF === void 0 ) rAF = true;\n\n\t  if (this.options.native) {\n\t    var listener = privated.getNodeListener.call(this);\n\t    listener.addEventListener('scroll', this.boundFns.debounceScroll);\n\t  } else if (this.virtualScroll) {\n\t    this.virtualScroll.on(this.boundFns.virtualScroll);\n\t  }\n\n\t  if (this.scrollBar) {\n\t    this.scrollBar.on();\n\t  }\n\n\t  rAF && privated.rAF.call(this);\n\n\t  privated.resize.call(this);\n\t  if (this.options.autoUpdate) {\n\t    window.addEventListener('resize', this.boundFns.resize);\n\t  }\n\n\t  this.state.ready = true;\n\t  privated.ready.call(this);\n\t};\n\n\t/**\n\t * Disables the rolly instance.\n\t * - stops listening events (scroll and resize),\n\t * - cancels any requested animation frame if {@param cAF} is true.\n\t * @param {boolean} cAF - whether to cancel a requested animation frame.\n\t */\n\tRolly.prototype.off = function off (cAF) {\n\t    if ( cAF === void 0 ) cAF = true;\n\n\t  if (this.options.native) {\n\t    var listener = privated.getNodeListener.call(this);\n\t    listener.removeEventListener('scroll', this.boundFns.debounceScroll);\n\t  } else if (this.virtualScroll) {\n\t    this.virtualScroll.off(this.boundFns.virtualScroll);\n\t  }\n\n\t  if (this.scrollBar) {\n\t    this.scrollBar.off();\n\t  }\n\n\t  cAF && privated.cAF.call(this);\n\n\t  if (this.options.autoUpdate) {\n\t    window.removeEventListener('resize', this.boundFns.resize);\n\t  }\n\t  this.state.ready = false;\n\t};\n\n\t/**\n\t * Destroys the rolly instance.\n\t * - removes DOM classes.\n\t * - if native, removes the fake height for scroll.\n\t * - else if `options.noScrollBar` is false, removes the fake scroll bar.\n\t * - calls {@link Rolly#off}.\n\t */\n\tRolly.prototype.destroy = function destroy () {\n\t  var type = this.options.native ? 'native' : 'virtual';\n\t  var direction = this.options.vertical ? 'y' : 'x';\n\n\t  this.DOM.listener.classList.remove((\"is-\" + type + \"-scroll\"));\n\t  this.DOM.listener.classList.remove((direction + \"-scroll\"));\n\t  this.DOM.view.classList.remove('rolly-view');\n\n\t  if (this.virtualScroll) {\n\t    this.virtualScroll.destroy();\n\t    this.virtualScroll = null;\n\t  }\n\n\t  this.off();\n\n\t  this.options.native\n\t    ? privated.removeFakeScrollHeight.call(this)\n\t    : !this.options.noScrollBar && privated.removeFakeScrollBar.call(this);\n\t};\n\n\t/**\n\t * Reloads the rolly instance with new options.\n\t * @param {object} options - Options of rolly.\n\t */\n\tRolly.prototype.reload = function reload (options) {\n\t    if ( options === void 0 ) options = this.options;\n\n\t  this.destroy();\n\n\t  this.boundFns = privated.getBoundFns.call(this);\n\n\t  // Extend default options\n\t  this.options = privated.extendOptions.call(this, options);\n\n\t  var ref = this;\n\t    var DOM = ref.DOM;\n\t  this.DOM = Object.assign({}, DOM,\n\t    {listener: this.options.listener,\n\t    view: this.options.view});\n\n\t  privated.initScenes.call(this);\n\n\t  this.init();\n\t};\n\n\t/**\n\t * Scrolls to a target (number|DOM element).\n\t * @param {number|object} target - The target to scroll to.\n\t * @param {object} options - Options.\n\t */\n\tRolly.prototype.scrollTo = function scrollTo (target, options) {\n\t    var assign;\n\n\t  var defaultOptions = {\n\t    offset: 0,\n\t    position: 'start',\n\t    callback: null,\n\t  };\n\t  options = Object.assign({}, defaultOptions, options);\n\n\t  var ref = this.options;\n\t    var vertical = ref.vertical;\n\t  var scrollOffset = this.state.current;\n\t  var bounding = null;\n\t  var newPos = scrollOffset + options.offset;\n\n\t  if (typeof target === 'string') {\n\t    (assign = utils.getElements(target), target = assign[0]);\n\t  }\n\n\t  switch (typeof target) {\n\t    case 'number':\n\t    default:\n\t      newPos = target;\n\t      break;\n\n\t    case 'object':\n\t      if (!target) { return; }\n\t      bounding = target.getBoundingClientRect();\n\t      newPos += vertical ? bounding.top : bounding.left;\n\t      break;\n\t  }\n\n\t  switch (options.position) {\n\t    case 'center':\n\t    default:\n\t      newPos -= vertical ? this.state.height / 2 : this.state.width / 2;\n\t      break;\n\n\t    case 'end':\n\t      newPos -= vertical ? this.state.height : this.state.width;\n\t      break;\n\t  }\n\n\t  if (options.callback) {\n\t    this.privateState.scrollTo.callback = options.callback;\n\t  }\n\n\t  // FIXME: if the scrollable element is not the body, this won't work\n\t  if (this.options.native) {\n\t    this.options.vertical\n\t      ? window.scrollTo(0, newPos)\n\t      : window.scrollTo(newPos, 0);\n\t  } else {\n\t    privated.setTarget.call(this, newPos);\n\t  }\n\t};\n\n\t/**\n\t * Updates the states and re-setup all the cache of the rolly instance.\n\t * Useful if the width/height of the view changed.\n\t * - calls {@link Rolly#resize}.\n\t */\n\tRolly.prototype.update = function update () {\n\t  privated.resize.call(this);\n\t};\n\n\tvar rolly = function (options) { return new Rolly(options); };\n\n\treturn rolly;\n\n}));\n","import rolly from 'rolly.js';\r\n\r\nconst r = rolly({\r\n  view: document.body,\r\n  native: false,\r\n  // other options\r\n});\r\nr.init();"]}